import { Dataset, Example } from "types/datasets";
import { createClient, type PhoenixClient } from "../client";
import type {
  Evaluator,
  Experiment,
  ExperimentParameters,
  ExperimentRun,
  ExperimentTask,
  RanExperiment,
} from "../types/experiments";
import { promisifyResult } from "utils/promisifyResult";

export type RunExperimentParams = {
  experimentName: string;
  client?: PhoenixClient;
  dataset: Dataset | string | Example[];
  task: ExperimentTask;
  evaluators: Evaluator[];
  repetitions?: number;
  projectName?: string;
};

export async function runExperiment({
  experimentName,
  client: _client,
  dataset: _dataset,
  task,
  evaluators,
  repetitions = 1,
  projectName = "default",
}: RunExperimentParams): Promise<RanExperiment> {
  const client = _client ?? createClient();
  const dataset = await getDataset({ dataset: _dataset, client });
  const experimentParams: ExperimentParameters = {
    nRepetitions: repetitions,
    // TODO: Make configurable?
    nExamples: dataset.examples.length,
  };
  const experiment: Experiment = {
    id: id(),
    datasetId: dataset.id,
    datasetVersionId: dataset.versionId,
    repetitions,
    projectName: projectName,
  };

  // TODO: logger w/ verbosity
  // eslint-disable-next-line no-console
  console.info(
    `ðŸ§ª Running experiment ${experimentName} on ${dataset.id} with ${task} and ${evaluators.length} evaluators`,
  );

  // Run task against all examples, for each repetition
  // TODO: Summarize repetitions
  type ExperimentRunId = string;
  const runs: Record<ExperimentRunId, ExperimentRun> = {};
  await Promise.all(
    Array.from({ length: repetitions }, (_, i) =>
      runTask({
        repetition: i + 1,
        experimentId: experiment.id,
        task,
        dataset,
        onComplete: (run) => {
          runs[run.id] = run;
        },
      }),
    ),
  );
  // TODO: logger w/ verbosity
  // eslint-disable-next-line no-console
  console.info(`âœ… Task runs completed`);

  // TODO: Evaluate runs

  return {
    ...experiment,
    params: experimentParams,
    runs,
  };
}

/**
 * Run a task against all examples in a dataset.
 */
function runTask({
  experimentId,
  task,
  dataset,
  repetition,
  onComplete,
}: {
  /** The id of the experiment */
  experimentId: string;
  /** The task to run */
  task: ExperimentTask;
  /** The dataset to run the task on */
  dataset: Dataset;
  /** The repetition number */
  repetition: number;
  /** A callback to call when the task is complete */
  onComplete: (run: ExperimentRun) => void;
}) {
  const run = async (example: Example) => {
    const thisRun: ExperimentRun = {
      id: id(),
      traceId: id(),
      experimentId,
      datasetExampleId: example.id,
      startTime: new Date(),
      repetitionNumber: repetition,
      endTime: new Date(), // will get replaced with actual end time
      output: null,
      error: null,
    };
    try {
      const taskOutput = await promisifyResult(task(example));
      thisRun.output = JSON.stringify(taskOutput);
    } catch (error) {
      thisRun.error = error instanceof Error ? error.message : "Unknown error";
    }
    thisRun.endTime = new Date();
    onComplete(thisRun);
  };
  return Promise.all(dataset.examples.map(run));
}

/**
 * Return a dataset object from the input.
 *
 * If the input is a string, assume it is a dataset id and fetch the dataset from the client.
 * If the input is an array of examples, create a new dataset from the examples then return it.
 * If the input is a dataset, return it as is.
 *
 * @param dataset - The dataset to get.
 * @returns The dataset.
 */
async function getDataset({
  dataset,
}: {
  dataset: Dataset | string | Example[];
  client: PhoenixClient;
}): Promise<Dataset> {
  if (typeof dataset === "string") {
    throw new Error("TODO: implement dataset fetching by id");
  }
  if (Array.isArray(dataset)) {
    throw new Error("TODO: implement dataset creation from examples");
  }
  return dataset;
}

/**
 * Wrap an evaluator function in an object with a name property.
 *
 * @param name - The name of the evaluator.
 * @param evaluate - The evaluator function.
 * @returns The evaluator object.
 */
export function asEvaluator(
  name: string,
  evaluate: Evaluator["evaluate"],
): Evaluator {
  return {
    name,
    evaluate,
  };
}

/**
 * Generate a unique id.
 *
 * @deprecated Use id generated by phoenix instead.
 * @returns A unique id.
 */
export function id(): string {
  let id = 0;
  return (() => {
    id++;
    return id.toString();
  })();
}
